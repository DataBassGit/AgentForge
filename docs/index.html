<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading Documentation...</title> <!-- Title will be updated -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    /* Reuse the same CSS styles from the previous "manual list" example */
    :root {
      --bg-color: #0d1117; --text-color: #c9d1d9; --panel-bg: #161b22; --border-color: #30363d;
      --link-color: #58a6ff; --link-hover-color: #80baff; --selected-bg: #1f6feb; --selected-text: #ffffff;
      --hover-bg: #21262d; --code-bg: #21262d; --error-border: #f85149; --success-border: #3fb950;
      --info-border: #58a6ff; --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      --font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { font-size: 16px; }
    body { font-family: var(--font-sans); display: flex; min-height: 100vh; flex-direction: column; background-color: var(--bg-color); color: var(--text-color); }
    #nav-list { background-color: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 1rem 1.5rem; flex-shrink: 0; }
    #nav-list h3 { margin-bottom: 0.75rem; font-size: 1.2em; color: var(--text-color); }
    #nav-list ul { list-style-type: none; padding-left: 0; }
    #nav-list li { margin-bottom: 0.3rem; }
    #nav-list a { display: inline-block; padding: 4px 8px; border-radius: 5px; text-decoration: none; color: var(--link-color); transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out; white-space: nowrap; }
    #nav-list a:hover { background-color: var(--hover-bg); color: var(--link-hover-color); text-decoration: none; }
    #nav-list a.selected { background-color: var(--selected-bg); color: var(--selected-text); font-weight: 600; }
    #nav-list a::before { display: inline-block; width: 1.5em; text-align: center; margin-right: 4px; font-size: 0.9em; }
    #nav-list a.dir-link::before { content: 'ðŸ“'; }
    #nav-list a.file-link::before { content: 'ðŸ“„'; } /* Generic file */
    #nav-list a.md-link::before { content: 'ðŸ“'; }
    #nav-list a.parent-link::before { content: 'â¤´ï¸'; }
    #content-area { flex: 1; overflow-y: auto; padding: 1.5rem 2rem; background-color: var(--bg-color); }
    #status-message { background-color: var(--panel-bg); border-left: 4px solid var(--info-border); padding: 0.8rem 1rem; margin-bottom: 1.5rem; border-radius: 4px; display: none; font-size: 0.9em; }
    #status-message.error { border-left-color: var(--error-border); }
    #status-message.success { border-left-color: var(--success-border); }
    .markdown-body { /* ... include the full .markdown-body styles ... */
        font-size: 1rem; line-height: 1.6; word-wrap: break-word; color: var(--text-color); }
    .markdown-body > *:first-child { margin-top: 0 !important; } .markdown-body > *:last-child { margin-bottom: 0 !important; }
    .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { margin-top: 1.5em; margin-bottom: 1em; font-weight: 600; line-height: 1.25; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
    .markdown-body h1 { font-size: 2em; } .markdown-body h2 { font-size: 1.5em; } .markdown-body h3 { font-size: 1.25em; } .markdown-body h4 { font-size: 1em; } .markdown-body h5 { font-size: 0.875em; } .markdown-body h6 { font-size: 0.85em; color: #8b949e; }
    .markdown-body h1:first-child, .markdown-body h2:first-child { margin-top: 0; }
    .markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre, .markdown-body details { margin-top: 0; margin-bottom: 1em; }
    .markdown-body ul, .markdown-body ol { padding-left: 2em; } .markdown-body li > p { margin-bottom: 0.25em; }
    .markdown-body a { color: var(--link-color); text-decoration: none; } .markdown-body a:hover { text-decoration: underline; color: var(--link-hover-color); }
    .markdown-body code { font-family: var(--font-mono); padding: 0.2em 0.4em; margin: 0; font-size: 85%; background-color: var(--code-bg); border-radius: 6px; }
    .markdown-body pre { font-family: var(--font-mono); font-size: 85%; line-height: 1.45; background-color: var(--code-bg); border-radius: 6px; padding: 1rem; overflow: auto; word-wrap: normal; }
    .markdown-body pre > code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; }
    .markdown-body blockquote { margin-left: 0; padding: 0 1em; color: #8b949e; border-left: 0.25em solid var(--border-color); }
    .markdown-body img { max-width: 100%; height: auto; box-sizing: content-box; background-color: var(--bg-color); }
    .markdown-body hr { height: .25em; padding: 0; margin: 1.5em 0; background-color: var(--border-color); border: 0; }
    .markdown-body table { display: block; width: max-content; max-width: 100%; overflow: auto; border-spacing: 0; border-collapse: collapse; margin-bottom: 1em; }
    .markdown-body th, .markdown-body td { padding: 6px 13px; border: 1px solid var(--border-color); } .markdown-body th { font-weight: 600; }
    .markdown-body tr { background-color: var(--bg-color); border-top: 1px solid var(--border-color); } .markdown-body tr:nth-child(2n) { background-color: var(--panel-bg); }

    @media (min-width: 769px) { body { flex-direction: row; } #nav-list { width: 300px; height: 100vh; border-bottom: none; border-right: 1px solid var(--border-color); overflow-y: auto; } #content-area { height: 100vh; overflow-y: auto; flex: 1; } }
  </style>
</head>
<body>

  <nav id="nav-list">
    <h3 id="current-folder-name">Loading...</h3>
    <ul id="file-list">
      <!-- File list will be populated by JavaScript -->
      <li><i>Fetching directory contents...</i></li>
    </ul>
  </nav>

  <main id="content-area">
    <div id="status-message"></div>
    <div id="markdown-content" class="markdown-body">
      <!-- Content loads here -->
      <h1>Welcome</h1>
      <p>Fetching directory listing. Select a file to view its content.</p>
      <hr>
      <p><small>Powered by GitHub API, markdown-it, and highlight.js.</small></p>
    </div>
  </main>

  <script>
    // --- Configuration ---
    const GITHUB_OWNER = 'DataBassGit';
    const GITHUB_REPO = 'AgentForge';
    const GITHUB_BRANCH = 'main'; // Or your default branch
    // Path within the repo that corresponds to the root of your GitHub Pages site
    // Since your site is sourced from the /docs folder, this is 'docs'.
    const REPO_DOCS_ROOT = 'docs';
    // --- End Configuration ---

    const contentElement = document.getElementById('markdown-content');
    const statusElement = document.getElementById('status-message');
    const fileListElement = document.getElementById('file-list');
    const currentFolderNameEl = document.getElementById('current-folder-name');
    let currentSelectedLink = null;
    let currentRepoPath = ''; // Will store the calculated path relative to the *repo* root (e.g., 'docs' or 'docs/subdir')

    let md; // Declare md variable here

    // --- Status Display ---
    function showStatus(message, type = 'info', duration = 4000) {
        statusElement.textContent = message;
        statusElement.className = ''; // Clear previous types
        statusElement.classList.add(type); // 'info', 'success', 'error'
        statusElement.style.display = 'block';

        if (type !== 'error' && duration > 0) {
            setTimeout(() => {
                if (statusElement.textContent === message) { // Hide only if msg hasn't changed
                   statusElement.style.display = 'none';
                }
            }, duration);
        }
    }

    // --- Get Path from URL ---
    function getRepoPathFromURL() {
      // Define the expected base URL path on GitHub Pages (must start and end with /)
      // Assumes your site is at owner.github.io/repo/
      const expectedLiveBasePath = `/${GITHUB_REPO}/`;

      // Get the current full pathname from the URL
      let currentPathname = window.location.pathname;

      // --- Path Cleaning ---
      try {
        currentPathname = decodeURIComponent(currentPathname);
      } catch (e) { console.error("Error decoding pathname:", currentPathname, e); }
      let cleanedPath = currentPathname.replace(/index\.html$/, '');
      if (cleanedPath.length > 1 && cleanedPath.endsWith('/')) {
          cleanedPath = cleanedPath.slice(0, -1);
      }
      // --- End Path Cleaning ---

      let pathRelativeToWebsiteRoot = '';

      // --- Determine Path Relative to Website Root (which is /docs in repo) ---
      // Check if running on the expected GitHub Pages structure owner.github.io/repo/
      if (cleanedPath.startsWith(expectedLiveBasePath)) {
          // Extract the part *after* /repo/
          // Example: /AgentForge/guides/api -> guides/api
          pathRelativeToWebsiteRoot = cleanedPath.substring(expectedLiveBasePath.length);
          console.log(`Detected live structure. Path relative to website root: "${pathRelativeToWebsiteRoot}"`);
      }
      // Fallback for Localhost/Other (less reliable)
      else {
           // ASSUMPTION: The path after the domain/port corresponds to the path relative to website root
           // Example: http://localhost:8000/guides/api -> guides/api
           pathRelativeToWebsiteRoot = cleanedPath.startsWith('/') ? cleanedPath.substring(1) : cleanedPath;
           console.warn(`URL path "${currentPathname}" doesn't match expected live structure "${expectedLiveBasePath}". Assuming "${pathRelativeToWebsiteRoot}" is the path relative to the website root (/docs in repo).`);
           if (window.location.protocol === 'file:') {
                console.error("Running from file:// protocol. Path detection is unreliable. Serve via HTTP.");
           }
      }
      // --- End Path Determination ---


      // --- Construct Full Repository Path ---
      // Start with REPO_DOCS_ROOT ('docs').
      // Append the pathRelativeToWebsiteRoot *if* it's not empty.
      let repoPath = REPO_DOCS_ROOT;
      if (pathRelativeToWebsiteRoot) {
          // Ensure single slash between parts, handles if REPO_DOCS_ROOT is empty string too
          repoPath = `${repoPath}/${pathRelativeToWebsiteRoot}`;
      }

      // Final cleanup: remove potential double slashes and any leading/trailing slashes
      repoPath = repoPath.replace(/\/+/g, '/').replace(/^\/|\/$/g, '');
      // --- End Repository Path Construction ---

      console.log(`Path Determination:
        - Full Pathname: ${window.location.pathname}
        - Cleaned Path: ${cleanedPath}
        - Relative Website Path: ${pathRelativeToWebsiteRoot}
        - Calculated Repo API Path: ${repoPath}`);

      return repoPath;
    }


    // --- Build File List ---
    async function populateFileList() {
      currentRepoPath = getRepoPathFromURL(); // This now correctly gives 'docs' or 'docs/subdir'
      const apiUrl = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${currentRepoPath}?ref=${GITHUB_BRANCH}`;

      // Update heading based on path *relative* to the docs root for display
      const displayPath = currentRepoPath.substring(REPO_DOCS_ROOT.length).replace(/^\//, '') || 'Root'; // Show 'Root' or 'subdir'
      currentFolderNameEl.textContent = displayPath;
      document.title = `${displayPath} - ${GITHUB_REPO}`;

      fileListElement.innerHTML = '<li><i>Fetching directory contents...</i></li>';

      try {
        const response = await fetch(apiUrl, { headers: { 'Accept': 'application/vnd.github.v3+json' } });
        if (!response.ok) {
          if (response.status === 404) { throw new Error(`Directory not found in repo: ${currentRepoPath}. Check path/branch.`); }
          else if (response.status === 403) { throw new Error(`API Forbidden (Rate Limit?) Status: ${response.status}`); }
          else { throw new Error(`GitHub API error! Status: ${response.status} - ${response.statusText}`); }
        }
        const items = await response.json();
        fileListElement.innerHTML = '';

        // Add Parent Directory Link (if not at the REPO_DOCS_ROOT itself)
        const isAtDocsRoot = currentRepoPath === REPO_DOCS_ROOT;
        if (!isAtDocsRoot) {
            const li = document.createElement('li');
            li.innerHTML = `<a href="../" class="parent-link">Parent Directory</a>`;
            fileListElement.appendChild(li);
        }

        // Sort items: directories first, then files, alphabetically
        items.sort((a, b) => {
          if (a.type === 'dir' && b.type !== 'dir') return -1;
          if (a.type !== 'dir' && b.type === 'dir') return 1;
          return a.name.localeCompare(b.name);
        });

        // Add items from API
        items.forEach(item => {
          const li = document.createElement('li');
          let link = '';
          if (item.type === 'dir') {
            link = `<a href="${item.name}/" class="dir-link">${item.name}/</a>`;
          } else if (item.type === 'file') {
            if (item.name.toLowerCase().endsWith('.md')) {
              link = `<a href="${item.name}" class="md-link" data-filename="${item.name}">${item.name}</a>`;
            } else if (item.name.toLowerCase() !== 'index.html') { // Hide index.html itself
               link = `<a href="${item.html_url}" class="file-link" target="_blank">${item.name}</a>`;
            }
          }
          if(link) {
            li.innerHTML = link;
            fileListElement.appendChild(li);
          }
        });

        // Check if only parent link is present (if not at root) or list is empty (if at root)
         if (fileListElement.children.length === (isAtDocsRoot ? 0 : 1)) {
            fileListElement.innerHTML += '<li><i>Empty directory.</i></li>';
         }

        autoLoadReadme(); // Attempt to load README after list is built

      } catch (error) {
        console.error('Error fetching directory contents:', error);
        fileListElement.innerHTML = `<li><i>Error loading list: ${error.message}</i></li>`;
        showStatus(`Error loading directory list: ${error.message}`, 'error', 0);
        document.title = `Error - ${GITHUB_REPO}`;
      }
    }

    // --- Markdown Loading and Rendering ---
    async function loadAndRenderMarkdown(fileName, linkElement) {
        showStatus(`Loading ${fileName}...`, 'info', 0);
        if (currentSelectedLink) {
            currentSelectedLink.classList.remove('selected');
        }
        linkElement.classList.add('selected');
        currentSelectedLink = linkElement;

        // Construct the full path within the repo for the raw content URL
        const fileRepoPath = `${currentRepoPath}/${fileName}`; // currentRepoPath is already 'docs' or 'docs/subdir'
        const rawUrl = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${fileRepoPath}`;

        try {
            // Check md AGAIN just before use for safety
            if (typeof md !== 'function' && typeof window.markdownit !== 'function') {
                throw new Error("Markdown renderer (md) is not available.");
            }
            const renderer = md || window.markdownit; // Fallback just in case
            if (typeof renderer !== 'function') {
                throw new Error("Markdown renderer is not a function.");
            }
            const mdInstance = renderer({html:true, linkify:true, typographer:true}); // Ensure options are set

            const response = await fetch(rawUrl);
            if (!response.ok) {
                 if (response.status === 404) { throw new Error(`File not found at ${rawUrl}`); }
                 else { throw new Error(`HTTP error fetching raw content! Status: ${response.status}`); }
            }
            const markdownContent = await response.text();

            // Use the instance created above or the globally initialized 'md'
            const htmlContent = md ? md.render(markdownContent) : mdInstance.render(markdownContent);

            contentElement.innerHTML = htmlContent;
            contentElement.querySelectorAll('pre code').forEach((block) => {
                if (window.hljs) {
                    window.hljs.highlightElement(block);
                } else {
                    console.warn("highlight.js (hljs) not ready for highlighting.");
                }
            });
            const firstHeading = contentElement.querySelector('h1, h2');
            document.title = firstHeading ? `${firstHeading.textContent}` : fileName;
            showStatus(`Loaded ${fileName} successfully.`, 'success');
            document.getElementById('content-area').scrollTop = 0; // Scroll content to top

        } catch (error) {
            console.error('Error loading or rendering markdown:', error);
            contentElement.innerHTML = `<h1>Error</h1><p>Could not load <code>${fileName}</code>.</p><p><strong>Error:</strong> ${error.message}</p>`;
            document.title = `Error - ${fileName}`;
            showStatus(`Error loading ${fileName}: ${error.message}`, 'error', 0);
            if (currentSelectedLink === linkElement) { // Deselect on error
                 linkElement.classList.remove('selected');
                 currentSelectedLink = null;
            }
        }
    }

    // --- Auto-load README ---
    function autoLoadReadme() {
         const readmeLink = fileListElement.querySelector('a.md-link[data-filename="README.md"], a.md-link[data-filename="readme.md"]');
         if (readmeLink) {
             // Check if content area is still the default welcome message OR empty
             const isDefaultContent = contentElement.querySelector('h1')?.textContent === 'Welcome' || contentElement.innerHTML.trim() === '';
             if(isDefaultContent) {
                 console.log("Attempting to autoload README...");
                 loadAndRenderMarkdown(readmeLink.dataset.filename, readmeLink);
             } else {
                 console.log("Content already loaded, skipping README autoload.");
             }
         } else {
             console.log("No README found in list for autoloading.");
         }
    }


    // --- Initialization ---
    window.addEventListener('load', () => {
        console.log("Window 'load' event fired.");

        // Initialize markdown-it
        if (typeof window.markdownit === 'function') {
            console.log("markdown-it library IS available on window object.");
            try {
                 md = window.markdownit({ // Assign to the global 'md' variable
                    html: true,
                    linkify: true,
                    typographer: true,
                 });
                 console.log("markdown-it initialized successfully into 'md' variable.");
            } catch (e) {
                 console.error("Error during markdown-it initialization:", e);
                 showStatus("Fatal Error: Could not initialize Markdown renderer. Check console.", 'error', 0);
                 return;
            }
        } else {
            console.error("FATAL: markdown-it library is NOT available on window object.");
            showStatus("Fatal Error: Markdown library (markdown-it) failed to load. Check console and network tab.", 'error', 0);
            contentElement.innerHTML = `<h1>Initialization Error</h1><p>The required Markdown rendering library (markdown-it) failed to load from the CDN. Please check your network connection, browser console (F12), and network tab for errors related to <code>markdown-it.min.js</code>.</p>`;
            return;
        }

        // Check highlight.js
        if (typeof window.hljs !== 'object' || window.hljs === null) {
             console.warn("highlight.js (hljs) library not found or failed to load. Syntax highlighting will be disabled.");
        } else {
             console.log("highlight.js library loaded.");
        }


        // Proceed with fetching the file list
        populateFileList();

        // Event delegation for clicking on file/directory links
        fileListElement.addEventListener('click', (event) => {
            const target = event.target.closest('a');
            if (!target) return;
            if (target.classList.contains('md-link')) {
                event.preventDefault();
                const fileName = target.dataset.filename;
                if (fileName) { loadAndRenderMarkdown(fileName, target); }
            }
            // Let directory and parent links navigate normally
        });
    });

    console.log("Initial script parsing finished. Waiting for 'load' event...");

  </script>

</body>
</html>