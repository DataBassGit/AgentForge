<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading Documentation...</title> <!-- Title will be updated -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    /* Reuse the same CSS styles from the previous "manual list" example */
    :root {
      --bg-color: #0d1117; --text-color: #c9d1d9; --panel-bg: #161b22; --border-color: #30363d;
      --link-color: #58a6ff; --link-hover-color: #80baff; --selected-bg: #1f6feb; --selected-text: #ffffff;
      --hover-bg: #21262d; --code-bg: #21262d; --error-border: #f85149; --success-border: #3fb950;
      --info-border: #58a6ff; --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      --font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { font-size: 16px; }
    body { font-family: var(--font-sans); display: flex; min-height: 100vh; flex-direction: column; background-color: var(--bg-color); color: var(--text-color); }
    #nav-list { background-color: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 1rem 1.5rem; flex-shrink: 0; }
    #nav-list h3 { margin-bottom: 0.75rem; font-size: 1.2em; color: var(--text-color); }
    #nav-list ul { list-style-type: none; padding-left: 0; }
    #nav-list li { margin-bottom: 0.3rem; }
    #nav-list a { display: inline-block; padding: 4px 8px; border-radius: 5px; text-decoration: none; color: var(--link-color); transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out; white-space: nowrap; }
    #nav-list a:hover { background-color: var(--hover-bg); color: var(--link-hover-color); text-decoration: none; }
    #nav-list a.selected { background-color: var(--selected-bg); color: var(--selected-text); font-weight: 600; }
    #nav-list a::before { display: inline-block; width: 1.5em; text-align: center; margin-right: 4px; font-size: 0.9em; }
    #nav-list a.dir-link::before { content: '📁'; }
    #nav-list a.file-link::before { content: '📄'; } /* Generic file */
    #nav-list a.md-link::before { content: '📝'; }
    #nav-list a.parent-link::before { content: '⤴️'; }
    #content-area { flex: 1; overflow-y: auto; padding: 1.5rem 2rem; background-color: var(--bg-color); }
    #status-message { background-color: var(--panel-bg); border-left: 4px solid var(--info-border); padding: 0.8rem 1rem; margin-bottom: 1.5rem; border-radius: 4px; display: none; font-size: 0.9em; }
    #status-message.error { border-left-color: var(--error-border); }
    #status-message.success { border-left-color: var(--success-border); }
    .markdown-body { /* ... include the full .markdown-body styles ... */
        font-size: 1rem; line-height: 1.6; word-wrap: break-word; color: var(--text-color); }
    .markdown-body > *:first-child { margin-top: 0 !important; } .markdown-body > *:last-child { margin-bottom: 0 !important; }
    .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { margin-top: 1.5em; margin-bottom: 1em; font-weight: 600; line-height: 1.25; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
    .markdown-body h1 { font-size: 2em; } .markdown-body h2 { font-size: 1.5em; } .markdown-body h3 { font-size: 1.25em; } .markdown-body h4 { font-size: 1em; } .markdown-body h5 { font-size: 0.875em; } .markdown-body h6 { font-size: 0.85em; color: #8b949e; }
    .markdown-body h1:first-child, .markdown-body h2:first-child { margin-top: 0; }
    .markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre, .markdown-body details { margin-top: 0; margin-bottom: 1em; }
    .markdown-body ul, .markdown-body ol { padding-left: 2em; } .markdown-body li > p { margin-bottom: 0.25em; }
    .markdown-body a { color: var(--link-color); text-decoration: none; } .markdown-body a:hover { text-decoration: underline; color: var(--link-hover-color); }
    .markdown-body code { font-family: var(--font-mono); padding: 0.2em 0.4em; margin: 0; font-size: 85%; background-color: var(--code-bg); border-radius: 6px; }
    .markdown-body pre { font-family: var(--font-mono); font-size: 85%; line-height: 1.45; background-color: var(--code-bg); border-radius: 6px; padding: 1rem; overflow: auto; word-wrap: normal; }
    .markdown-body pre > code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; }
    .markdown-body blockquote { margin-left: 0; padding: 0 1em; color: #8b949e; border-left: 0.25em solid var(--border-color); }
    .markdown-body img { max-width: 100%; height: auto; box-sizing: content-box; background-color: var(--bg-color); }
    .markdown-body hr { height: .25em; padding: 0; margin: 1.5em 0; background-color: var(--border-color); border: 0; }
    .markdown-body table { display: block; width: max-content; max-width: 100%; overflow: auto; border-spacing: 0; border-collapse: collapse; margin-bottom: 1em; }
    .markdown-body th, .markdown-body td { padding: 6px 13px; border: 1px solid var(--border-color); } .markdown-body th { font-weight: 600; }
    .markdown-body tr { background-color: var(--bg-color); border-top: 1px solid var(--border-color); } .markdown-body tr:nth-child(2n) { background-color: var(--panel-bg); }

    @media (min-width: 769px) { body { flex-direction: row; } #nav-list { width: 300px; height: 100vh; border-bottom: none; border-right: 1px solid var(--border-color); overflow-y: auto; } #content-area { height: 100vh; overflow-y: auto; flex: 1; } }
  </style>
</head>
<body>

  <nav id="nav-list">
    <h3 id="current-folder-name">Loading...</h3>
    <ul id="file-list">
      <!-- File list will be populated by JavaScript -->
      <li><i>Fetching directory contents...</i></li>
    </ul>
  </nav>

  <main id="content-area">
    <div id="status-message"></div>
    <div id="markdown-content" class="markdown-body">
      <!-- Content loads here -->
      <h1>Welcome</h1>
      <p>Fetching directory listing. Select a file to view its content.</p>
      <hr>
      <p><small>Powered by GitHub API, markdown-it, and highlight.js.</small></p>
    </div>
  </main>

      <script>
    // --- Configuration ---
    const GITHUB_OWNER = 'DataBassGit';
    const GITHUB_REPO = 'AgentForge';
    const GITHUB_BRANCH = 'main';
    const REPO_DOCS_ROOT = 'docs';
    // --- End Configuration ---

    const contentElement = document.getElementById('markdown-content');
    const statusElement = document.getElementById('status-message');
    const fileListElement = document.getElementById('file-list');
    const currentFolderNameEl = document.getElementById('current-folder-name');
    let currentSelectedLink = null;
    let currentRepoPath = '';

    let md; // Declare md variable here

    // --- Status Display ---
    function showStatus(message, type = 'info', duration = 4000) { /* ... same ... */
        statusElement.textContent = message; statusElement.className = ''; statusElement.classList.add(type);
        statusElement.style.display = 'block';
        if (type !== 'error' && duration > 0) { setTimeout(() => { if (statusElement.textContent === message) { statusElement.style.display = 'none'; } }, duration); }
    }

    // --- Get Path from URL --- (CORRECTED VERSION)
    function getRepoPathFromURL() {
        // Base patterns to identify the docs root in the URL pathname
        // Handles cases like /docs/, /RepoName/docs/, /
        const docsRootPatternInUrl = new RegExp(`^/?(?:${GITHUB_REPO}/)?${REPO_DOCS_ROOT}/?`, 'i');
        const repoRootPatternInUrl = new RegExp(`^/?${GITHUB_REPO}/?`, 'i');

        let currentPathname = window.location.pathname.replace(/index\.html$/, ''); // Remove index.html

        let pathRelativeToDocsRoot = '';

        // Try matching GitHub Pages structure first (e.g., /Repo/docs/)
        if (currentPathname.toLowerCase().startsWith(`/${GITHUB_REPO.toLowerCase()}/${REPO_DOCS_ROOT.toLowerCase()}/`)) {
             const basePathToRemove = `/${GITHUB_REPO}/${REPO_DOCS_ROOT}/`;
             pathRelativeToDocsRoot = currentPathname.substring(basePathToRemove.length);
        }
        // Try matching simple /docs/ structure (e.g., served from domain root)
        else if (currentPathname.toLowerCase().startsWith(`/${REPO_DOCS_ROOT.toLowerCase()}/`)) {
             const basePathToRemove = `/${REPO_DOCS_ROOT}/`;
             pathRelativeToDocsRoot = currentPathname.substring(basePathToRemove.length);
        }
        // Try matching structure where site is served *from within* the 'docs' dir (e.g., localhost:8000/)
        // Needs careful check: Is it repo root or docs root? Let's assume if ONLY repo matches, it's served from repo root.
        else if (repoRootPatternInUrl.test(currentPathname) && !docsRootPatternInUrl.test(currentPathname)) {
             // This case is less common for docs sites. If URL is /RepoName/something_else,
             // it's likely outside the docs. Let's default to the docs root.
             console.warn(`URL path ${currentPathname} starts with repo name but not docs root. Assuming docs root.`);
             pathRelativeToDocsRoot = ''; // Default to root of docs
        }
        // Fallback: Assume served directly from *within* the docs directory,
        // so the pathname itself is relative to the docs root (e.g., /subdir/page.html maps to docs/subdir)
        else {
             console.warn("Cannot reliably determine deployment base path (e.g., /Repo/docs/ or /docs/). Assuming pathname is relative *within* the docs root.");
             // Remove leading slash only
             pathRelativeToDocsRoot = currentPathname.startsWith('/') ? currentPathname.substring(1) : currentPathname;
        }


        // Clean the relative path (remove trailing slash if any)
        pathRelativeToDocsRoot = pathRelativeToDocsRoot.replace(/\/$/, '');

        // Construct the final API path: REPO_DOCS_ROOT + cleaned relative path
        let finalApiPath = REPO_DOCS_ROOT;
        if (pathRelativeToDocsRoot) {
            finalApiPath += '/' + pathRelativeToDocsRoot;
        }

        // Final cleanup of slashes (just in case)
        finalApiPath = finalApiPath.replace(/\/+/g, '/').replace(/^\/|\/$/g, ''); // Remove leading/trailing slashes

        // console.log(`[getRepoPathFromURL] Pathname: ${window.location.pathname}, Calculated API Path: ${finalApiPath}`); // DEBUG
        return finalApiPath || REPO_DOCS_ROOT; // Ensure we always return at least the root path
    }

    // --- Build File List ---
    async function populateFileList() { /* ... same ... */
      currentRepoPath = getRepoPathFromURL(); // This now uses the corrected function
      // Log the path being used for the API call
      console.log(`[populateFileList] Using API path: ${currentRepoPath}`);
      const apiUrl = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${currentRepoPath}?ref=${GITHUB_BRANCH}`;
      const displayPath = currentRepoPath.replace(new RegExp(`^${REPO_DOCS_ROOT}/?`), '') || 'Root';
      currentFolderNameEl.textContent = displayPath;
      document.title = `${displayPath} - ${GITHUB_REPO}`;
      fileListElement.innerHTML = '<li><i>Fetching directory contents...</i></li>';
      try { /* ... fetch and list building ... */
        const response = await fetch(apiUrl, { headers: { 'Accept': 'application/vnd.github.v3+json' } });
        if (!response.ok) {
            if (response.status === 404) { throw new Error(`Directory not found: ${currentRepoPath}`); }
            else if (response.status === 403) { throw new Error(`API Forbidden (Rate Limit?) for path: ${currentRepoPath}`); }
            else { throw new Error(`API Error: ${response.status} for path: ${currentRepoPath}`); }
        }
        const items = await response.json(); fileListElement.innerHTML = '';
        const isAtDocsRoot = currentRepoPath === REPO_DOCS_ROOT || (REPO_DOCS_ROOT === '' && currentRepoPath === ''); // Adjust logic if REPO_DOCS_ROOT can be empty

        // Add parent link only if NOT at the defined REPO_DOCS_ROOT
        if (!isAtDocsRoot && currentRepoPath !== '') { // Also check currentRepoPath isn't empty just in case
             const parentPathParts = currentRepoPath.split('/');
             // If only one part (e.g., 'docs') and it IS the root, don't show parent.
             // If more than one part (e.g., 'docs/subdir'), go up.
             if (parentPathParts.length > 1 || (parentPathParts.length === 1 && parentPathParts[0] !== REPO_DOCS_ROOT)) {
                  const li = document.createElement('li');
                  // Calculate the correct relative URL for the parent link
                  // If current URL is /repo/docs/subdir/, parent is ../ which resolves to /repo/docs/
                  // If current URL is /docs/subdir/, parent is ../ which resolves to /docs/
                  // If current URL is /subdir/ (served from docs), parent is ../ which resolves to /
                  // This needs careful handling based on deployment... using '../' is simplest for relative links.
                  li.innerHTML = `<a href="../" class="parent-link">Parent Directory</a>`;
                  fileListElement.appendChild(li);
             }
        }

        items.sort((a, b) => { if (a.type === 'dir' && b.type !== 'dir') return -1; if (a.type !== 'dir' && b.type === 'dir') return 1; return a.name.localeCompare(b.name); });
        items.forEach(item => { const li = document.createElement('li'); let link = '';
          if (item.type === 'dir') { link = `<a href="${item.name}/" class="dir-link">${item.name}/</a>`; }
          else if (item.type === 'file') { if (item.name.toLowerCase().endsWith('.md')) { link = `<a href="${item.name}" class="md-link" data-filename="${item.name}">${item.name}</a>`; } else if (item.name.toLowerCase() !== 'index.html') { link = `<a href="${item.html_url}" class="file-link" target="_blank">${item.name}</a>`; } }
          if(link) { li.innerHTML = link; fileListElement.appendChild(li); } });

        // Check if list is empty *besides* the potential parent link
        const hasParentLink = fileListElement.querySelector('a.parent-link');
        if (fileListElement.children.length === (hasParentLink ? 1 : 0)) {
             fileListElement.innerHTML += '<li><i>Empty directory.</i></li>';
        }
        autoLoadReadme();
      } catch (error) {
         console.error('Error fetching dir contents:', error);
         fileListElement.innerHTML = `<li><i>Error: ${error.message}</i></li>`;
         showStatus(`Error loading list: ${error.message}`, 'error', 0);
         document.title = `Error - ${GITHUB_REPO}`;
      }
    }

    // --- Markdown Loading and Rendering ---
    async function loadAndRenderMarkdown(fileName, linkElement) { /* ... same ... */
        showStatus(`Loading ${fileName}...`, 'info', 0); if (currentSelectedLink) { currentSelectedLink.classList.remove('selected'); } linkElement.classList.add('selected'); currentSelectedLink = linkElement;
        // Construct the path relative to the repository root for the raw content URL
        const fileRepoPath = currentRepoPath ? `${currentRepoPath}/${fileName}` : fileName;
        // Ensure no double slashes if currentRepoPath was empty or ended with /
        const cleanedFileRepoPath = fileRepoPath.replace(/\/+/g, '/').replace(/^\//, ''); // Remove leading slash if present
        const rawUrl = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${cleanedFileRepoPath}`;
        console.log(`[loadAndRenderMarkdown] Fetching raw content from: ${rawUrl}`); // Log the raw URL

        try {
            // **** Check md AGAIN just before use ****
            if (typeof md !== 'object' && typeof window.markdownit !== 'function') { // Check md is an object instance or the factory exists
                 throw new Error("Markdown renderer (md) is not available or not initialized correctly.");
            }
            // Use the initialized md instance
            const renderer = md;
            if (typeof renderer?.render !== 'function') { // Check if the instance has a render method
                 // Maybe try initializing again? Or fallback to window.markdownit if desperate?
                 if(typeof window.markdownit === 'function'){
                      console.warn("Re-initializing markdown-it instance.");
                      md = window.markdownit({html:true, linkify:true, typographer:true});
                 } else {
                      throw new Error("Markdown renderer instance is invalid and factory is unavailable.");
                 }
            }
             // **** End Check ****

            const response = await fetch(rawUrl);
            if (!response.ok) { if (response.status === 404) { throw new Error(`File not found: ${rawUrl}`); } else { throw new Error(`HTTP error fetching raw content! Status: ${response.status}`); } }
            const markdownContent = await response.text();

            const htmlContent = md.render(markdownContent); // Use the initialized instance

            contentElement.innerHTML = htmlContent;
            contentElement.querySelectorAll('pre code').forEach((block) => { if (window.hljs) { window.hljs.highlightElement(block); } else { console.warn("hljs not ready."); } });
            const firstHeading = contentElement.querySelector('h1, h2'); document.title = firstHeading ? `${firstHeading.textContent}` : fileName; showStatus(`Loaded ${fileName} successfully.`, 'success'); document.getElementById('content-area').scrollTop = 0;
        } catch (error) { /* ... error handling ... */
            console.error('Error loading/rendering markdown:', error); contentElement.innerHTML = `<h1>Error</h1><p>Could not load <code>${fileName}</code>.</p><p><strong>Error:</strong> ${error.message}</p>`; document.title = `Error - ${fileName}`; showStatus(`Error loading ${fileName}: ${error.message}`, 'error', 0); if (currentSelectedLink === linkElement) { linkElement.classList.remove('selected'); currentSelectedLink = null; }
        }
    }

    // --- Auto-load README ---
    function autoLoadReadme() { /* ... same ... */
         const readmeLink = fileListElement.querySelector('a.md-link[data-filename="README.md"], a.md-link[data-filename="readme.md"]'); if (readmeLink) { const isDefaultContent = contentElement.querySelector('h1')?.textContent === 'Welcome'; if(isDefaultContent) { loadAndRenderMarkdown(readmeLink.dataset.filename, readmeLink); } }
    }

    // --- Initialization ---
    // Using window.onload event - fires after all resources are loaded
    window.addEventListener('load', () => {
        console.log("Window 'load' event fired.");

        // Explicitly check if the library is available
        if (typeof window.markdownit === 'function') {
            console.log("markdown-it library IS available on window object.");
            try {
                 md = window.markdownit({ // Assign to the global 'md' variable
                    html: true,
                    linkify: true,
                    typographer: true,
                 });
                 console.log("markdown-it initialized successfully into 'md' variable.");
            } catch (e) {
                 console.error("Error during markdown-it initialization:", e);
                 showStatus("Fatal Error: Could not initialize Markdown renderer. Check console.", 'error', 0);
                 return; // Stop if initialization fails
            }
        } else {
            // Library failed to load or define itself globally
            console.error("FATAL: markdown-it library is NOT available on window object.");
            showStatus("Fatal Error: Markdown library (markdown-it) failed to load. Check console and network tab.", 'error', 0);
            // Display a more prominent error in the main content area
            contentElement.innerHTML = `<h1>Initialization Error</h1><p>The required Markdown rendering library (markdown-it) failed to load from the CDN. Please check your network connection, browser console (F12), and network tab for errors related to <code>markdown-it.min.js</code>.</p>`;
            return; // Stop further execution
        }

        // Check highlight.js too, although less critical for core function
        if (typeof window.hljs !== 'object' || window.hljs === null) {
             console.warn("highlight.js (hljs) library not found or failed to load. Syntax highlighting will be disabled.");
             // No need to stop execution, just warn
        } else {
             console.log("highlight.js library loaded.");
        }


        // Proceed with fetching the file list etc. ONLY if md was initialized
        populateFileList();

        // Event delegation for clicking on file/directory links
        fileListElement.addEventListener('click', (event) => {
            const target = event.target.closest('a');
            if (!target) return;

            // Let browser handle external links and non-md files normally
            if (target.classList.contains('file-link') || target.target === '_blank') {
                return;
            }

            // Handle directory links and MD file links via JS
            if (target.classList.contains('dir-link') || target.classList.contains('md-link') || target.classList.contains('parent-link')) {
                 event.preventDefault(); // Prevent default navigation

                 if (target.classList.contains('md-link')) {
                    const fileName = target.dataset.filename;
                    if (fileName) { loadAndRenderMarkdown(fileName, target); }
                 } else if (target.classList.contains('dir-link') || target.classList.contains('parent-link')) {
                    // Navigate to the new directory path - browser handles relative URL resolution
                    window.location.href = target.href;
                    // NOTE: Since this causes a page reload, populateFileList will run again
                    // on the new page load because it's triggered by window.onload.
                 }
            }
        });

        // Handle back/forward navigation
        window.addEventListener('popstate', (event) => {
             console.log("Popstate event fired - navigating via history.");
             // Re-populate the file list and potentially load README based on the new URL
             populateFileList();
             // Clear existing content to show loading state
             contentElement.innerHTML = `<h1>Loading...</h1><p>Fetching content for the current path.</p>`;
        });

    });

    console.log("Initial script parsing finished. Waiting for 'load' event...");

</script>

</body>
</html>