# agent.py
from typing import Any, Dict, Optional, List
from .config import Config
from agentforge.apis.base_api import BaseModel
from agentforge.utils.logger import Logger
from agentforge.utils.prompt_processor import PromptProcessor
from agentforge.utils.parsing_processor import ParsingProcessor


class Agent:
    def __init__(self, agent_name: Optional[str] = None, log_file: Optional[str] = 'agentforge'):
        """
        Initialize an Agent instance with necessary configurations and services.
        
        Args:
            agent_name: Name of the agent. Defaults to class name if not provided.
            log_file: Name of the log file. Defaults to 'agentforge'.
        """
        self.agent_name: str = agent_name if agent_name is not None else self.__class__.__name__
        self.logger: Logger = Logger(self.agent_name, log_file)

        self.prompt = None
        self.result = None
        self.output = None
        self.parsed_result = None
        self.persona = None
        self.images = []

        # Initialize services
        self.config = Config()
        self.prompt_processor = PromptProcessor()
        self.parsing_processor = ParsingProcessor()
        
        # Initialize attributes and configurations
        self._initialize_data_attributes()
        self._initialize_agent_config()

    def _initialize_data_attributes(self) -> None:
        """Initialize all agent data attributes to their default values."""
        # Configuration
        self.agent_config: Optional[Any] = None
        self.model: Optional[BaseModel] = None
        self.persona: Optional[Dict[str, Any]] = None
        
        # Prompt related
        self.prompt: Optional[Dict[str]] = None
        self.prompt_template: Optional[Dict[str, Any]] = None
        self.template_data: Dict[str, Any] = {}
        
        # Results and output
        self.result: Optional[str] = None
        self.parsed_result: Optional[Any] = None
        self.output: Optional[str] = None

        # Media
        self.images: List[str] = []
        
    # ---------------------------------
    # Execution
    # ---------------------------------

    def run(self, **kwargs: Any) -> Optional[str]:
        """
        Execute the agent's workflow from data loading through output building.
        
        Args:
            **kwargs: Keyword arguments to incorporate into the agent's data.
            
        Returns:
            The output generated by the agent or None if execution failed.
        """
        try:
            self.logger.info(f"{self.agent_name} - Running...")
            self._execute_workflow(**kwargs)
            self.logger.info(f"{self.agent_name} - Done!")
            return self.output
        except Exception as e:
            self.logger.error(f"Agent execution failed: {e}")
            return None

    def _execute_workflow(self, **kwargs: Any) -> None:
        """Execute the complete agent workflow steps."""
        self.load_data(**kwargs)
        self.process_data()
        self.render_prompt()
        self.run_model()
        self.parse_result()
        self.post_process_result()
        self.build_output()

    # ---------------------------------
    # Configuration Loading
    # ---------------------------------

    def _initialize_agent_config(self) -> None:
        """Load all agent configurations."""
        self.agent_config = self.config.load_agent_data(self.agent_name)
        self.prompt_template = self.agent_config.prompts
        self.model = self.agent_config.model
        self.load_persona_data()
        
    def load_persona_data(self) -> None:
        """Load persona data if personas are enabled in system settings."""
        if not self.agent_config.settings.system.persona.enabled or not self.agent_config.persona:
            return
        
        self.persona = self.agent_config.persona.copy()
        self.template_data['persona'] = self.persona
        self.logger.debug(f"Persona Data Loaded for '{self.agent_name}'.")

    # ---------------------------------
    # Data Loading
    # ---------------------------------

    def load_data(self, **kwargs: Any) -> None:
        """
        Load all data needed for prompt generation, including dynamic updates.
        
        Args:
            **kwargs: Additional data to incorporate into template variables.
        """
        if self.agent_config.settings.system.misc.on_the_fly:
            self._initialize_agent_config()

        self.load_additional_data()
        self.template_data.update(kwargs)

    def load_additional_data(self) -> None:
        """
        Load custom additional data for the agent.
        Override this method in subclasses to load custom data.
        """
        pass

    # ---------------------------------
    # Processing
    # ---------------------------------

    def process_data(self) -> None:
        """
        Process loaded data before generating prompts.
        Override this method in subclasses to implement custom data processing.
        """
        pass

    def render_prompt(self) -> None:
        """Render prompt templates with the current template data."""
        self.prompt = self.prompt_processor.render_prompts(self.prompt_template, self.template_data)

    # ---------------------------------
    # Model Execution
    # ---------------------------------

    def run_model(self) -> None:
        """Execute the model with the rendered prompt and configured parameters."""
        if self.agent_config.settings.system.debug.mode:
            self.result = self.agent_config.simulated_response
            return

        self._execute_model_generation()

    def _execute_model_generation(self) -> None:
        """Execute the actual model generation with configured parameters."""
        params = self._build_model_params()
        # `generate` may return str or raw bytes (for TTS).
        result = self.model.generate(self.prompt, **params)

        # Preserve raw bytes; strip only when we have text.
        if isinstance(result, str):
            result = result.strip()

        self.result = result

    def _build_model_params(self) -> Dict[str, Any]:
        """Build parameters for model generation."""
        params = self.agent_config.params.copy()
        params['agent_name'] = self.agent_name
        
        if self.images:
            params['images'] = self.images

        # TODO: This needs verification against prompt_processor.render_prompts(), audio may not be in the prompt but a separate parameter.
        # Allow callers to supply raw audio for STT models via agent.run(audio=<bytes-or-path>)
        if 'audio' in self.template_data:
            params['audio'] = self.template_data['audio']

        return params

    # ---------------------------------
    # Result Handling
    # ---------------------------------

    def parse_result(self) -> None:
        """Handle text vs. binary results.

        • Text → optional structured parsing.
        • Bytes → save to disk via `_route_audio_save` and return the file path.
        """

        # Audio bytes – treat as TTS output
        if isinstance(self.result, (bytes, bytearray)):
            saved_path = self._route_audio_save(self.result)
            self.parsed_result = saved_path  # downstream components will use the path
            return

        # Otherwise, default behaviour
        self.parsed_result = self.parsing_processor.parse_by_format(
            self.result, self.agent_config.parse_response_as
        )

    # -----------------------------------------------------------------
    # Audio helpers
    # -----------------------------------------------------------------
    def _route_audio_save(self, blob: bytes, fmt: str = "wav") -> str:
        """Persist TTS bytes to disk and optionally auto-play.

        Behaviour is driven by the *audio* section in `settings/system.yaml`:

            1. `audio.save_files` – if *true*, save to `audio.save_dir`.
               • If `audio.save_dir` is blank, fall back to `settings.system.paths.audio`
                 or the OS temp directory.
            2. If `audio.save_files` is *false*, content is still written to the OS
               temp dir so that a valid file path is returned, but it will not be
               persisted elsewhere.
            3. `audio.autoplay` – when *true*, the saved file is auto-played using
               common platform tools (afplay/paplay/aplay/ffplay).
        """
        import os
        import tempfile
        import datetime
        import pathlib
        import platform
        import subprocess

        audio_cfg = getattr(self.agent_config.settings.system, "audio", None)

        # Determine save behavior
        save_enabled: bool = getattr(audio_cfg, "save_files", False) if audio_cfg else False

        # Fallback directory logic
        cfg_paths = getattr(self.agent_config.settings.system, "paths", {})
        default_dir = None
        if isinstance(cfg_paths, dict):
            default_dir = cfg_paths.get("audio")
        else:
            default_dir = getattr(cfg_paths, "audio", None)

        base_dir: str
        if save_enabled:
            base_dir = (getattr(audio_cfg, "save_dir", "") or default_dir or tempfile.gettempdir())
        else:
            # Still need to save somewhere to hand a path back; use temp dir.
            base_dir = tempfile.gettempdir()

        # Ensure directory exists
        pathlib.Path(base_dir).mkdir(parents=True, exist_ok=True)

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        file_path = os.path.join(base_dir, f"tts_{timestamp}.{fmt}")

        with open(file_path, "wb") as fp:
            fp.write(blob)

        # Optional auto-play controlled by config
        auto_play = getattr(audio_cfg, "autoplay", False) if audio_cfg else False

        if auto_play:
            try:
                system = platform.system()
                if system == "Darwin":
                    subprocess.Popen(["afplay", file_path])
                elif system == "Linux":
                    # Try paplay → aplay → ffplay
                    for cmd in (["paplay", file_path], ["aplay", file_path], ["ffplay", "-nodisp", "-autoexit", file_path]):
                        try:
                            subprocess.Popen(cmd)
                            break
                        except FileNotFoundError:
                            continue
                # On Windows or unknown, silently skip
            except Exception as exc:
                self.logger.warning(f"Auto-play failed: {exc}")

        return file_path

    def post_process_result(self) -> None:
        """
        Extension point for additional processing after parsing the model's response.
        """
        pass

    def build_output(self) -> None:
        """
        Build the final output for the agent. By default, the output is set to the parsed result.
        Override this method in subclasses to implement custom output building.
        """
        self.output = self.parsed_result
