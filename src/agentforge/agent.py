# agent.py

from typing import Any, Dict, Optional, List

from .config import Config
from agentforge.apis.base_api import BaseModel
from agentforge.utils.logger import Logger
from agentforge.utils.prompt_processor import PromptProcessor


class Agent:
    def __init__(self, agent_name: Optional[str] = None, log_file: Optional[str] = 'agentforge'):
        """
        Initialize an Agent instance with necessary configurations and services.
        
        Args:
            agent_name: Name of the agent. Defaults to class name if not provided.
            log_file: Name of the log file. Defaults to 'agentforge'.
        """
        self.agent_name: str = agent_name if agent_name is not None else self.__class__.__name__
        self.logger: Logger = Logger(self.agent_name, log_file)
        
        # Initialize services
        self.config = Config()
        self.prompt_processor = PromptProcessor()
        
        # Initialize data attributes
        self._initialize_data_attributes()
        
        # Load configuration
        self.initialize_agent_config()

    def _initialize_data_attributes(self) -> None:
        """Initialize all agent data attributes to their default values."""
        self.agent_data: Optional[Dict[str, Any]] = None
        self.persona: Optional[Dict[str, Any]] = None
        self.model: Optional[BaseModel] = None
        self.prompt_template: Optional[Dict[str, Any]] = None
        self.template_data: Dict[str, Any] = {}
        self.prompt: Optional[Dict[str]] = None
        self.result: Optional[str] = None
        self.output: Optional[str] = None
        self.images: List[str] = []

    # ---------------------------------
    # Execution
    # ---------------------------------

    def run(self, **kwargs: Any) -> Optional[str]:
        """
        Execute the agent's workflow from data loading through output building.
        
        Args:
            **kwargs: Keyword arguments to incorporate into the agent's data.
            
        Returns:
            The output generated by the agent or None if execution failed.
        """
        try:
            self.logger.info(f"{self.agent_name} - Running...")
            
            self._execute_workflow(**kwargs)
            
            self.logger.info(f"{self.agent_name} - Done!")
            return self.output
        except Exception as e:
            self.logger.error(f"Agent execution failed: {e}")
            return None

    def _execute_workflow(self, **kwargs: Any) -> None:
        """Execute the complete agent workflow steps."""
        self.load_data(**kwargs)
        self.process_data()
        self.render_prompt()
        self.run_model()
        self.parse_result()
        self.post_process_result()
        self.build_output()

    # ---------------------------------
    # Configuration Loading
    # ---------------------------------

    def initialize_agent_config(self) -> None:
        """Load all agent configurations."""
        self.load_agent_data()
        self.load_prompt_template()
        self.load_persona_data()
        self.load_model()

    def load_agent_data(self) -> None:
        """Load and validate the agent's configuration data."""
        self.agent_data = self.config.load_agent_data(self.agent_name).copy()
        self._validate_agent_data()

    def load_prompt_template(self) -> None:
        """Load and validate prompt templates for the agent."""
        self.prompt_template = self.agent_data.get('prompts', {})
        
        if not self.prompt_template:
            self._raise_config_error(f"No prompts defined for agent '{self.agent_name}'.")

        self.prompt_processor.check_prompt_format(self.prompt_template)
        self.logger.debug(f"Prompts for '{self.agent_name}' validated.")

    def load_persona_data(self) -> None:
        """Load persona data if personas are enabled in system settings."""
        if not self._is_persona_enabled():
            return
            
        self._load_and_add_persona()

    def _is_persona_enabled(self) -> bool:
        """Check if personas are enabled in agent settings."""
        return self.agent_data['settings']['system']['persona'].get('enabled', False)

    def _load_and_add_persona(self) -> None:
        """Load persona data and add it to template variables."""
        self.persona = self.agent_data.get('persona', {})
        self._validate_persona_data()
        self.logger.debug(f"Persona Data Loaded for '{self.agent_name}'.")
        
        if not self.persona:
            return
        
        self.template_data['persona'] = self.persona.copy()

    def load_model(self) -> None:
        """Load and validate the model for the agent."""
        self.model = self.agent_data.get('model')
        
        if not self.model:
            self._raise_config_error(f"Model not specified for agent '{self.agent_name}'.")

    # ---------------------------------
    # Validation
    # ---------------------------------

    def _validate_agent_data(self) -> None:
        """Ensure agent data has all required keys and structure."""
        if not self.agent_data:
            self._raise_config_error(f"Agent data for '{self.agent_name}' is not loaded.")

        self._validate_required_keys()
        self._validate_system_settings()

    def _validate_required_keys(self) -> None:
        """Validate that all required keys are present in agent data."""
        required_keys = ['params', 'prompts', 'settings']
        for key in required_keys:
            if key not in self.agent_data:
                self._raise_config_error(f"Agent data missing required key '{key}' for agent '{self.agent_name}'.")

    def _validate_system_settings(self) -> None:
        """Validate that system settings are properly configured."""
        if 'system' not in self.agent_data['settings']:
            self._raise_config_error(f"Agent data settings missing 'system' key for agent '{self.agent_name}'.")

    def _validate_persona_data(self) -> None:
        """Validate persona data if available."""
        if not self.persona:
            self.logger.warning(f"Personas are enabled but no persona data found for agent '{self.agent_name}'.")
            return
            
        self.logger.debug(f"Persona for '{self.agent_name}' validated!")

    def _raise_config_error(self, message: str) -> None:
        """Log error and raise ValueError for configuration issues."""
        self.logger.error(message)
        raise ValueError(message)

    # ---------------------------------
    # Data Loading
    # ---------------------------------

    def load_data(self, **kwargs: Any) -> None:
        """
        Load all data needed for prompt generation, including dynamic updates.
        
        Args:
            **kwargs: Additional data to incorporate into template variables.
        """
        if self._should_reload_config():
            self.initialize_agent_config()

        self.load_additional_data()
        self.template_data.update(kwargs)

    def _should_reload_config(self) -> bool:
        """Check if configuration should be reloaded on the fly."""
        return self.agent_data['settings']['system']['misc'].get('on_the_fly', False)

    def load_additional_data(self) -> None:
        """
        Load custom additional data for the agent.
        
        Override this method in subclasses to load custom data.
        
        Note: If your subclass needs to load data from memory or storage,
        you should implement this method or add a new method for that purpose.
        Memory is exclusively managed through cogs.
        """
        pass

    # ---------------------------------
    # Processing
    # ---------------------------------

    def process_data(self) -> None:
        """
        Process loaded data before generating prompts.
        
        Override this method in subclasses to implement custom data processing.
        """
        pass

    def render_prompt(self) -> None:
        """Render prompt templates with the current template data."""
        self.prompt = self.prompt_processor.render_prompts(self.prompt_template, self.template_data)
        self.prompt_processor.validate_rendered_prompts(self.prompt)

    # ---------------------------------
    # Model Execution
    # ---------------------------------

    def run_model(self) -> None:
        """Execute the model with the rendered prompt and configured parameters."""
        if self._is_debug_mode():
            self.result = self.agent_data['simulated_response']
            return

        self._execute_model_generation()

    def _is_debug_mode(self) -> bool:
        """Check if agent is running in debug mode."""
        return self.agent_data['settings']['system']['debug'].get('mode', False)

    def _execute_model_generation(self) -> None:
        """Execute the actual model generation with configured parameters."""
        params = self._build_model_params()
        self.result = self.model.generate(self.prompt, **params).strip()

    def _build_model_params(self) -> Dict[str, Any]:
        """Build parameters for model generation."""
        params = self.agent_data.get("params", {}).copy()
        params['agent_name'] = self.agent_name
        
        if self.images:
            params['images'] = self.images
            
        return params

    # ---------------------------------
    # Result Handling
    # ---------------------------------

    def parse_result(self) -> None:
        """
        Process model output as needed.
        
        Override this method in subclasses to implement custom result parsing.
        """
        pass

    def post_process_result(self) -> None:
        """
        Extension point for additional processing after parsing the model's response.
        
        This method is an extension point meant to be overridden in subclasses.
        It's called after the model result has been parsed but before building
        the final output, making it ideal for any additional data transformations,
        side effects, or external system interactions.
        """
        pass

    def build_output(self) -> None:
        """
        Build the final output from model results.
        
        Override this method in subclasses to implement custom output formatting.
        By default, uses the raw model result as output.
        """
        self.output = self.result
